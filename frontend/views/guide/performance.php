<h1>
    Настройка производительности
</h1>
<hr />
<p>
    Производительность вашего веб-приложения основана на двух частях. Во-первых - это производительность фреймворка, а во-вторых - это само приложение. Yii имеет довольно низкое влияние на производительность вашего приложения из коробки и может быть доработано в дальнейшем для продакшен среды. Что касается приложения, то мы предоставим некоторые из лучших практик вместе с примерами о том, как применить их к Yii.
</p>
<h2>
    Подготовка среды
</h2>
<hr />
<p>
    Хорошо настроенная среда для запуска PHP приложения действительно имеет значение. Для того, чтобы получить максимальную производительность:
</p>
<ul>
    <li>Всегда используйте последнюю стабильную версию PHP. Каждый крупный релиз приносит значительное увеличение производительности и снижение использования памяти.</li>
    <li>Используйте APC для PHP 5.4 и меньше, или Opcache для PHP 5.5 и выше и многое другое. Это дает очень хороший прирост производительности.</li>
</ul>
<h2>
    Подготовка фреймворка для производства
</h2>
<hr />
<h3>
    Отключение режима отладки
</h3>
<p>
    Первое, что вы должны сделать, прежде чем развертывать приложение для продакшен среды - это отключение режима отладки. Приложение Yii работает в режиме отладки, если константа YII_DEBUG определяется как true в index.php, чтобы отключить отладку укажите следующее в вашем index.php:<br />
    <?php
    highlight_string("<?php
defined('YII_DEBUG') or define('YII_DEBUG', false);
?>");
    ?>
</p>
<p>
    Режим отладки очень полезен на стадии разработки, но это будет влиять на производительность, так как некоторые компоненты вызывают дополнительную нагрузку в режиме отладки. Например, message logger может записывать дополнительную информацию отладки для каждого сообщения в журнал.
</p>
<h3>
    Включение PHP кэша кода операции
</h3>
<p>
    Включение PHP кэша кода операции улучшает любую производительность PHP приложений и значительно снижает потребление памяти. Yii не является исключением. Он был протестирован с PHP 5.5 OPcache и расширением APC PHP. Оба кэша и оптимизируют промежуточный PHP код и помогают избежать времени, затрачиваемого на интерпретацию скриптов PHP при каждом запросе.
</p>
<h3>
    Включение кэширования схемы базы данных для ActiveRecord
</h3>
<p>
    Если приложение использует Active Record, мы должны включить кэширование схемы, чтобы сэкономить время разбора схемы базы данных. Это может быть сделано путем установки свойства Connection::enableSchemaCache в true в конфигурации приложения protected/config/main.php:<br />
    <?php
    highlight_string("<?php
return [
    // ...
    'components' => [
        // ...
        'db' => [
            'class' => 'yii\\db\\Connection',
            'dsn' => 'mysql:host=localhost;dbname=mydatabase',
            'username' => 'root',
            'password' => '',
            'enableSchemaCache' => true,

            // Duration of schema cache.
            // 'schemaCacheDuration' => 3600,

            // Name of the cache component used. Default is 'cache'.
            //'schemaCache' => 'cache',
        ],
        'cache' => [
            'class' => 'yii\\caching\\FileCache',
        ],
    ],
];
?>");
    ?>
</p>
<p>
    Обратите внимание, что компонент приложения cache должен быть настроен.
</p>
<h3>
    Объединение и сведение к минимуму Assets'ов
</h3>
<p>
    Можно объединить и свести к минимуму assets'ы, как правило это JavaScript и CSS, для того, чтобы немного улучшить время загрузки страницы и, следовательно, поставить лучший опыт для конечного пользователя вашего приложения.
</p>
<p>
    Для того, чтобы узнать, как это может быть достигнуто, обратитесь к разделу assets.
</p>
<h3>
    Использование лучшего хранилища для сессий
</h3>
<p>
    По умолчанию PHP использует файлы для обработки сессий. Это хорошо для development и небольших проектов, но когда дело доходит до обработки одновременных (конкурирующих) запросов лучше переключиться на другое хранилище, такое как базы данных. Вы можете сделать это, настроив приложение в protected/config/main.php:<br />
    <?php
    highlight_string("<?php
return [
    // ...
    'components' => [
        'session' => [
            'class' => 'yii\\web\\DbSession',

            // Set the following if want to use DB component other than
            // default 'db'.
            // 'db' => 'mydb',

            // To override default session table set the following
            // 'sessionTable' => 'my_session',
        ],
    ],
];
?>");
    ?>
</p>
<p>
    Вы можете использовать CacheSession для хранения сессий с использованием кэша. Обратите внимание, что некоторые хранилища кэша такие как Memcached не имеют никаких гарантий, что данные сессии не будут потеряны, что приводит к получению непредвиденных logouts'ов.
</p>
<p>
    Если у вас есть Redis на вашем сервере, то настоятельно рекомендуется использовать его в качестве хранилища для сессий.
</p>
<h2>
    Улучшение приложения
</h2>
<hr />
<h3>
    Использование техник кэширования на стороне сервера
</h3>
<p>
    Как описано в разделе кэширования, Yii предоставляет несколько решений для кэширования, которые могут значительно улучшить производительность веб-приложения. Если генерация некоторых данных занимает много времени, то мы можем использовать для них подход кэширования данных, чтобы уменьшить частоту создания данных; Если часть страницы остается неизменной, то мы можем использовать подход кэширования фрагментов, чтобы уменьшить его частоту отрисовки; Если целая страница остается относительно статичной, то мы можем использовать подход кэширования страницы, чтобы сохранить время отрисовки для всей страницы.
</p>
<h3>
    Использование HTTP, чтобы сэкономить время обработки и пропускной способности
</h3>
<p>
    Использование HTTP кэширования значительно экономит время обработки, пропускной способности и ресурсов. Оно может быть реализовано путем отправки либо ETag или Last-Modified заголовков в вашем ответе (response) приложения. Если браузер реализован в соответствии с HTTP спецификацией (большинство браузеров соответствуют), то содержание будет получено, только если оно отличается от того, что это было в предыдущих запросах.
</p>
<p>
    Формирование правильных заголовков является трудоемкой задачей, поэтому Yii предоставляет ярлык в виде контроллера фильтра [[yii\web\HttpCache]]. С его помощью очень легко. В контроллере необходимо реализовать метод behaviors вроде следующего:<br />
    <?php
    highlight_string("<?php
public function behaviors()
{
    return [
        'httpCache' => [
            'class' => \\yii\\web\\HttpCache::className(),
            'only' => ['list'],
            'lastModified' => function (\$action, \$params) {
                \$q = new Query();
                return strtotime(\$q->from('users')->max('updated_timestamp'));
            },
            // 'etagSeed' => function (\$action, \$params) {
                // return // generate etag seed here
            //}
        ],
    ];
}
?>");
    ?>
</p>
<p>
    В приведенном выше коде можно использовать либо etagSeed или lastModified. Реализация обоих не нужна. Цель состоит в том, чтобы определить, было ли содержание изменено, таким образом это дешевле, чем выборка и отрисовка этого контента. lastModified должен вернуть метку времени последней модификации содержимого, а etagSeed должен вернуть строку, которая затем используется для генерации значения заголовка ETag.
</p>
<h3>
    Оптимизация базы данных
</h3>
<p>
    Извлечение данных из базы часто является узким местом производительности веб-приложения. Хотя использование кэширования может смягчить потери, но оно не в полной мере решает эту проблему. Когда база данных содержит огромные объемы данных и в кэше данные некорректны, то выборка последних данных может быть слишком дорогой без надлежащей схемы данных или запросов.
</p>
<p>
    Делайте индексы мудро в базе данных. Индексация может сделать запросы на выборку намного быстрее, но это может замедлить INSERT, UPDATE или DELETE запросы.
</p>
<p>
    Для сложных запросов, рекомендуется создать представление (view) в базе данных вместо использования запросов внутри кода PHP, которые СУБД разбирает каждый раз.
</p>
<p>
    Не злоупотребляйте Active Record. Хотя Active Record является удобной проекцией данных в стиле ООП, но производительность в связи с этим понижается, так что она должна создать один или несколько объектов для представления каждой строки результата запроса. Для приложений, интенсивно работающих с данными, использование DAO или API базы данных на более низком уровне может быть лучшим выбором.
</p>
<p>
    Не в последнюю очередь, надо использовать LIMIT в ваших SELECT запросах. Это позволяет избежать получение избыточных данных из базы и расхода памяти, выделенной для PHP.
</p>
<h3>
    Использование asArray
</h3>
<p>
    Хороший способ экономии памяти и времени обработки на страницах только для чтения - это использование метода asArray класса ActiveRecord.<br />
    <?php
    highlight_string("<?php
class PostController extends Controller
{
    public function actionIndex()
    {
        \$posts = Post::find()->orderBy('id DESC')->limit(100)->asArray()->all();
        return \$this->render('index', ['posts' => \$posts]);
    }
}
?>");
    ?>
</p>
<p>
    В представлении вы должны работать с полями каждой отдельной записи в $posts как с массивом:<br />
    <?php
    highlight_string("<?php
foreach (\$posts as \$post) {
    echo \$post['title'].\"<br>\";
}
?>");
    ?>
</p>
<p>
    Обратите внимание, что вы можете использовать нотацию массива, даже если asArray не был указан и вы работаете с объектами AR.
</p>
<h3>
    Обработка данных в фоновом режиме
</h3>
<p>
    Для ответа на запросы пользователей быстрее, вы можете обрабатывать тяжелые части запроса позже, если нет необходимости в немедленной реакции.
</p>
<ul>
    <li>Cron jobs + console.</li>
    <li>queues + handlers.</li>
</ul>
<p>
    Подлежит обсуждению
</p>
<h3>
    Если ничего не помогает
</h3>
<p>
    Если ничего не помогает, то не следует думать, что можно исправить проблемы с производительностью. Всегда профилируйте код вместо, перед, изменением любого кода. Следующие инструменты могут быть полезны:
</p>
<ul>
    <li><a href="/yiisoft/yii2/blob/master/docs/guide/module-debug.md" target="_blank">Yii debug toolbar and debugger</a></li>
    <li><a href="http://xdebug.org/docs/profiler" target="_blank">XDebug profiler</a></li>
    <li><a href="http://www.php.net/manual/en/book.xhprof.php" target="_blank">XHProf</a></li>
</ul>