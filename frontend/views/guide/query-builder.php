<h1>
    Конструктор запросов и запросы
</h1>
<hr />
<p>
    Yii обеспечивает базовый слой доступа к базе данных, как описано в разделе основы баз данных. Слой доступа к базам данных предоставляет возможность низкоуровневого взаимодействия с базой данных. Это полезно в некоторых ситуациях и в то же время это может быть утомительно и чревато ошибками писать сырые SQLs. Альтернативный подход состоит в использовании построителя запросов. Query Builder предоставляет объектно-ориентированный подход для генерации запросов, который будет выполнен.
</p>
<p>
    Типичное использование построителя запросов выглядит следующим образом:<br />
    <?php
    highlight_string("<?php
\$rows = (new \\yii\\db\\Query())
    ->select('id, name')
    ->from('tbl_user')
    ->limit(10)
    ->all();

// which is equivalent to the following code:
\$query = (new \\yii\\db\\Query())
    ->select('id, name')
    ->from('tbl_user')
    ->limit(10);

// Create a command. You can get the actual SQL using \$command->sql
\$command = \$query->createCommand();

// Execute the command:
\$rows = \$command->queryAll();
?>");
    ?>
</p>
<h2>
    Методы объекта Query (Запрос)
</h2>
<hr />
<p>
    Как вы можете видеть [[yii\db\Query]] является основным игроком, с которым вам придется иметь дело. За сценой, Query на самом деле ответственен только для представления различной информации запроса. Реальная логика построения запросов делается методом [[yii\db\QueryBuilder]] при вызове CreateCommand(), и выполнение запроса осуществляется [[yii\db\Command]].
</p>
<p>
    Для удобства [[yii\db\Query]] предоставляет набор наиболее часто используемых методов запроса, которые будут строить запрос, выполнять его, и возвращать результат. Например,
</p>
<ul>
    <li>[[yii\db\Query::all()|all()]]: - строит запрос, выполняет его и возвращает все результаты в виде массива.</li>
    <li>[[yii\db\Query::one()|one()]]: - возвращает первую строку результата.</li>
    <li>[[yii\db\Query::column()|column()]]: - возвращает первый столбец результата.</li>
    <li>[[yii\db\Query::scalar()|scalar()]]: - возвращает первый столбец в первой строке результата.</li>
    <li>[[yii\db\Query::exists()|exists()]]: - возвращает значение, указывающее, существует ли результат запроса или нет.</li>
    <li>
        [[yii\db\Query::count()|count()]]: возвращает результат <code>COUNT</code> запроса.
        Другие подобные методы включают <code>sum()</code>, <code>average()</code>, <code>max()</code>, <code>min()</code>, которые поддерживают так называемый запросы агрегирования данных.
    </li>
</ul>
<h2>
    Строительство Запросов
</h2>
<hr />
<p>
    В дальнейшем, мы объясним, как строить различные положения в выражении SQL. Для простоты мы используем $query для представления объекта [[yii\db\Query]].
</p>
<h3>
    <code>
        SELECT
    </code>
</h3>
<p>
    Для того, чтобы сформировать основной запрос на выборку, вам нужно указать, какие столбцы выбрать и из какой таблицы:<br />
    <?php
    highlight_string("<?php
\$query->select('id, name')
    ->from('tbl_user');
?>");
    ?>
</p>
<p>
    Значения в Select опции могут быть определены как через запятую, как в описанном выше коде, так и в виде массива. Синтаксис массива особенно полезен при формировании динамического выбора:<br />
    <?php
    highlight_string("<?php
\$query->select(['id', 'name'])
    ->from('tbl_user');
?>");
    ?>
</p>
<blockquote>
    <p>
        Информация: Вам следует всегда использовать формат массива, если ваш пункт SELECT содержит выражения SQL. Это потому, что такие выражения SQL, как CONCAT(first_name, last_name) AS full_name могут содержать запятые. Если вы перечислите его вместе с другими столбцами в строке, то выражение может быть разделено на несколько частей запятыми, которые не соответствуют тому, что вы хотите увидеть.
    </p>
</blockquote>
<p>
    При указании столбцов, вы можете включить префиксы таблиц или псевдонимы столбцов, например, tbl_user.id, tbl_user.id AS user_id. Если вы используете массив для указания столбцов, то вы можете также использовать ключи массива указав псевдонимы столбцов, например, ['user_id' => 'tbl_user.id', 'user_name' => 'tbl_user.name'].
</p>
<p>
    Для выбора уникальных строк, вы можете вызвать метод distinct() следующим образом:<br />
    <?php
    highlight_string("<?php
\$query->select('user_id')->distinct()->from('tbl_post');
?>");
    ?>
</p>
<h3>
    <code>
        FROM
    </code>
</h3>To specify which table(s) to select data from, call from():
<p>
    Чтобы указать из каких таблиц(ы) выбирать данных, то надо вызвать метод from():<br />
    <?php
    highlight_string("<?php
\$query->select('*')->from('tbl_user');
?>");
    ?>
</p>
<p>
    Вы можете указать несколько таблиц с помощью разделенния запятыми в строке или массивом. Имена таблиц могут содержать префиксы схемы (например, 'public.tbl_user') и/или псевдонимы таблиц (например, 'tbl_user u'). Метод автоматически обрамляет кавычками имена таблиц, если они не содержат скобок (что означает таблица передается как подзапрос или выражение БД). Например,<br />
    <?php
    highlight_string("<?php
\$query->select('u.*, p.*')->from(['tbl_user u', 'tbl_post p']);
?>");
    ?>
</p>
<p>
    Когда таблицы задаются в виде массива, то вы также можете использовать ключи массива как псевдонимы таблиц (если таблица не нуждается в псевдониме, то не используйте строковый ключ). Например,<br />
    <?php
    highlight_string("<?php
\$query->select('u.*, p.*')->from(['u' => 'tbl_user u', 'p' => 'tbl_post']);
?>");
    ?>
</p>
<p>
    Вы можете указать подзапрос с использованием объекта запроса. В этом случае соответствующий ключ массива будет использоваться в качестве псевдонима для суб-запроса.<br />
    <?php
    highlight_string("<?php
\$subQuery = (new Query())->select('id')->from('tbl_user')->where('status=1');
\$query->select('*')->from(['u' => \$subQuery]);
?>");
    ?>
</p>
<h3>
    <code>
        WHERE
    </code>
</h3>Usually data is selected based upon certain criteria. Query Builder has some useful methods to specify these, the most powerful of which being where. It can be used in multiple ways.
<p>
    Обычно выбирают данные основанные на определенных критериях. Query Builder имеет некоторые полезные методы для их определения, наиболее мощным из которых является 'WHERE'. Он может быть использован несколькими способами.
</p>
<p>
    Самый простой способ применить условие, заключается в использовании строки:<br />
    <?php
    highlight_string("<?php
\$query->where('status=:status', [':status' => \$status]);
?>");
    ?>
</p>
<p>
    При использовании строки, убедитесь, что вы связываете параметры запроса, не создав запрос по конкатенации строк. Такой подход является безопасным для использования, следующий пример не безопасен:<br />
    <?php
    highlight_string("<?php
\$query->where(\"status=\$status\"); // Dangerous!
?>");
    ?>
</p>
<p>
    Вместо того, чтобы сразу же задать значение для 'status', вы можете сделать это, используя params или addParams:<br />
    <?php
    highlight_string("<?php
\$query->where('status=:status');
\$query->addParams([':status' => \$status]);
?>");
    ?>
</p>Multiple conditions can simultaneously be set in where using the hash format:
<p>
    Несколько условий одновременно могут быть установлены в 'where' используя формат хэш:<br />
    <?php
    highlight_string("<?php
\$query->where([
    'status' => 10,
    'type' => 2,
    'id' => [4, 8, 15, 16, 23, 42],
]);
?>");
    ?>
</p>
<p>
    Этот код будет генерировать следующий SQL:<br />
    <?php
    highlight_string("<?php
WHERE (`status` = 10) AND (`type` = 2) AND (`id` IN (4, 8, 15, 16, 23, 42))
?>");
    ?>
</p>
<p>
    NULL это специальное значение в базах данных и обрабатывается умно с помощью Query Builder. Этот код:<br />
    <?php
    highlight_string("<?php
\$query->where(['status' => null]);
?>");
    ?>
</p>
<p>
    результатом будет следующий код:<br />
    <?php
    highlight_string("<?php
WHERE (`status` IS NULL)
?>");
    ?>
</p>
<p>
    Еще одним способом использовать метод, является формат operator, который выглядит примерно так: [operator, operand1, operand2, ...].
</p>
<p>
    Operator может быть одним из следующих:
</p>

<ul>
    <li>and - операнды должны быть объединены вместе, используя AND. Например, ['and', 'id=1', 'id=2'] будет генерировать ID = 1 AND ID = 2. Если операнд является массивом, то он будет преобразован в строку, используя правила, описанные здесь. Например, ['and', 'type=1', ['or', 'id=1', 'id=2']] выдаст type=1 AND (id=1 OR id=2). Метод впредь не будет делать обрамление кавычками или экранирования.</li>
    <li>or - похож на and оператора за исключением того, что операнды объединяются с помощью OR.</li>
    <li>between - операнд 1 должен быть именем столбца, а операнды 2 и 3 должны быть начальными и конечными значениями диапазона столбца. Например, ['between', 'id', 1, 10] будет генерировать id BETWEEN 1 AND 10.</li>
    <li>not between - похож на between за исключением того, что BETWEEN заменяется NOT BETWEEN в созданном условии.</li>
    <li>in - операнд 1 должен быть именем столбца или выражением БД, и операнд 2 должен быть массивом, представляющим спектр значений того, что столбец или выражение БД должны соответствовать. Например, ['in', 'id', [1, 2, 3]] будет генерировать id IN (1, 2, 3). Метод будет правильно указывать имя столбца и экранированные значения в диапазоне.</li>
    <li>not in - похож на in оператора, разве что IN заменяется на NOT IN в созданном условии.</li>
    <li>like - операнд 1 должен быть именем столбца или выражением БД , и операнд 2 должен быть строкой или массивом, представляющим значения того чем должен быть столбец или выражение БД. Например, ['like', 'name', 'tester'] будет генерировать LIKE '%tester%'. Когда диапазон значений задается в виде массива, несколько предикатов LIKE будет сгенерировано и объединятся с помощью AND. Например, ['like', 'name', ['test', 'sample']] выдаст name LIKE '%test%' AND name LIKE '%sample%'. Вы также можете предоставить дополнительный третий операнд чтобы указать, как экранировать специальные символы в значениях . Операнд должен быть массивом отображений из специальных символов на их экранируемые пары. Если этот операнд не предусмотрен, то отображение экранирования по умолчанию будет использоваться. Вы можете использовать false или пустой массив, чтобы указать значение, что уже экранирован и никакого экранирования не должно применяться. Обратите внимание, что при использовании отображения экранирования (или третий операнд не предусмотрен), значения будут автоматически заключены мужду символами процента.</li>
    <li>or like - похоже на like оператор, за исключением того, что OR используется для объединения LIKE предикатов если операнд 2 является массивом.</li>
    <li>not like - похоже на like оператор, за исключением того, что LIKE заменяется на NOT LIKE в созданном условии.</li>
    <li>or not like - ​​похоже на not like оператор, за исключением того, что OR используется для объединения в предикате NOT LIKE.</li>
    <li>exists - требуется один операнд, который должен быть экземпляром [[yii\db\Query]], представляющим подзапрос. Он будет строить EXISTS (подзапрос) выражение.</li>
    <li>not exists - похож на exists оператор и строит NOT EXISTS (подзапрос) выражение.</li>
</ul>
<p>
    Если вы строите части условия динамически, то очень удобно использовать andWhere и orWhere:<br />
    <?php
    highlight_string("<?php
\$status = 10;
\$search = 'yii';

\$query->where(['status' => \$status]);
if (!empty(\$search)) {
    \$query->andWhere(['like', 'title', \$search]);
}
?>");
    ?>
</p>
<p>
    В случае если $search не пустой, то будет сгенерирован следующий SQL:<br />
    <?php
    highlight_string("<?php
WHERE (`status` = 10) AND (`title` LIKE '%yii%')
?>");
    ?>
</p>
<h3>
    <code>
        ORDER BY
    </code>
</h3>
<p>
    Для сортировки результатов запроса могут быть использованы orderBy и addOrderBy:<br />
    <?php
    highlight_string("<?php
\$query->orderBy([
    'id' => SORT_ASC,
    'name' => SORT_DESC,
]);
?>");
    ?>
</p>
<p>
    Здесь мы сортируем по полю id по возрастанию, а затем по полю name по убыванию.<br />
    <?php
    highlight_string("<?php
### `GROUP BY` and `HAVING`

In order to add `GROUP BY` to generated SQL you can use the following:

```php
\$query->groupBy('id, status');
?>");
    ?>
</p>
<p>
    Если вы хотите добавить еще одно поле после использования groupBy:<br />
    <?php
    highlight_string("<?php
\$query->addGroupBy(['created_at', 'updated_at']);
?>");
    ?>
</p>To add a HAVING condition the corresponding having method and its andHaving and orHaving can be used. Parameters for these are similar to the ones for where methods group:
<p>
    Чтобы добавить HAVING условие есть соответствующий having метод и его andHaving и orHaving можно использовать. Параметры для них похожи на параметры метода group:<br />
    <?php
    highlight_string("<?php
\$query->having(['status' => \$status]);
?>");
    ?>
</p>
<h3>
    <code>
        LIMIT и OFFSET
    </code>
</h3>
<p>
    Чтобы ограничить результат до 10 строк можно использовать метод limit:<br />
    <?php
    highlight_string("<?php
\$query->limit(10);
?>");
    ?>
</p>
<p>
    Чтобы пропустить первые 100 строк можно использовать метод offset:<br />
    <?php
    highlight_string("<?php
\$query->offset(100);
?>");
    ?>
</p>
<h3>
    <code>
        JOIN
    </code>
</h3>
<p>
    Условие JOIN генерируются в Query Builder, используя соответствующий метод join:
</p>
<ul>
    <li><code>innerJoin()</code></li>
    <li><code>leftJoin()</code></li>
    <li><code>rightJoin()</code></li>
</ul>
<p>
    Это левое объединение данных выбирает из двух связанных таблиц в одном запросе:<br />
    <?php
    highlight_string("<?php
\$query->select(['tbl_user.name AS author', 'tbl_post.title as title'])
    ->from('tbl_user')
    ->leftJoin('tbl_post', 'tbl_post.user_id = tbl_user.id');
?>");
    ?>
</p>
<p>
    В коде выше первый параметр метода leftJoin() задает таблицу для присоединения. Второй параметр определяет условие соединения.
</p>
<p>
    Если ваше приложение базы данных поддерживает и другие типы соединений, вы можете использовать их с помощью основного join метода:<br />
    <?php
    highlight_string("<?php
\$query->join('FULL OUTER JOIN', 'tbl_post', 'tbl_post.user_id = tbl_user.id');
?>");
    ?>
</p>
<p>
    Первый аргумент является типом соединения для выполнения. Второй параметр - это таблица для присоединения, а третий параметр - это условие соединения.
</p>
<p>
    Как и в FROM, вы также можете выполнить join с подзапросами. Для этого укажите подзапрос в виде массива, который должен содержать один элемент. Значение массива должно быть объектом Query, представляющим подзапрос, в то время как ключ массива является псевдонимом для подзапроса. Например,<br />
    <?php
    highlight_string("<?php
\$query->leftJoin(['u' => \$subQuery], 'u.id=author_id');
?>");
    ?>
</p>
<h3>
    <code>
        UNION
    </code>
</h3>
<p>
    UNION в SQL добавляет результаты одного запроса к результатам другого запроса. Возвращаемые столбцы в запросах должны совпадать. В Yii, чтобы построить его можно сначала сформировать два объекта запроса, а затем использовать метод union:<br />
    <?php
    highlight_string("<?php
\$query = new Query();
\$query->select(\"id, 'post' as type, name\")->from('tbl_post')->limit(10);

\$anotherQuery = new Query();
\$anotherQuery->select('id, 'user' as type, name')->from('tbl_user')->limit(10);

\$query->union(\$anotherQuery);
?>");
    ?>
</p>
<h2>
    Пакетный Запрос
</h2>
<hr />
<p>
    При работе с большим объемом данных, такие методы, как [[yii\db\Query::all()]] не пригодны, поскольку они требуют загрузки всех данных в память. Чтобы использовать минимум памяти, Yii обеспечивает так называемую поддержку пакетных запросов. Пакетный запрос делает возможным использование курсора данных и извлекает данные в пакетах.
</p>
<p>
    Пакетный запрос можно использовать так:<br />
    <?php
    highlight_string("<?php
use yii\\db\\Query;

\$query = (new Query())
    ->from('tbl_user')
    ->orderBy('id');

foreach (\$query->batch() as \$users) {
    // \$users is an array of 100 or fewer rows from the user table
}

// or if you want to iterate the row one by one
foreach (\$query->each() as \$user) {
    // \$user represents one row of data from the user table
}
?>");
    ?>
</p>
<p>
    Методы [[yii\db\Query::batch()]] и [[yii\db\Query::each()]] возвращают [[yii\db\BatchQueryResult]] объект, который реализует интерфейс итератора и, таким образом, может быть использован в foreach конструкции. В ходе первой итерации, происходит SQL запрос к базе данных. Данные с тех пор приносятся в пакетах в итерацие. По умолчанию размер пакета равен 100, то есть 100 строк данных в настоящее время выбираются в каждом пакете. Вы можете изменить размер пакета, передав первый параметр в метод batch() или each().
</p>
<p>
    По сравнению с [[yii\db\Query::all()]], пакетный запрос загружает только 100 строк данных за один раз в память. Если вы обрабатываете данные, а затем отбросываете их сразу же, то пакетный запрос может помочь сохранить использование памяти под limit.
</p>
<p>
    Если указать, что результат запроса надо проиндексировать каким-нибудь столбцом, то это можно сделать с помощью метода [[yii\db\Query::indexBy()]], то весь пакетный запрос будет по-прежнему содержать правильный индекс. Например,<br />
    <?php
    highlight_string("<?php
use yii\\db\\Query;

\$query = (new Query())
    ->from('tbl_user')
    ->indexBy('username');

foreach (\$query->batch() as \$users) {
    // \$users is indexed by the \"username\" column
}

foreach (\$query->each() as \$username => \$user) {
}
?>");
    ?>
</p>